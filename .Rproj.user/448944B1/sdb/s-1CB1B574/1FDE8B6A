{
    "contents" : "# Ranking script (RAS - Raw Aggregate Score)\n\n\n# IMPORTANT NOTE: NEED TO DESIGN THE UI AND SERVER FILES SO THAT THIS ISN'T RECALCULATED EVERY TIME\n\n# Thought process: I need a way to rank players as a total pool and individually by position as well.\n\n# Therefore, I need to create several options -->\n  # 1) allowing people to differentiate values of position players (within position, e.g. First Baseman A vs First Baseman B)\n  # 2) allow people to differentiate hitters from other hitters, pitchers from other pitchers \n  # 3) allow people to differentiate the value of all players from each other, e.g. Starting pitcher A vs First Baseman A\n  # Task 3 is more complicated, consult dad on how he thinks this should work\n\nlibrary(shiny)\n\ngetNumPlayers <- function(dataSets) {\n  numPlayers = nrow(dataSets[1])\n  for (i in 1:length(dataSets)) {\n    if (nrow(dataSets[i]) > numPlayers) numPlayers = nrow(dataSets[i])\n  }\n  return(numPlayers)\n}\n\n# NEED FUNCTION THAT CALCULATES MAX PROJECTED VALUES FOR EACH CATEGORY for each set of projection data\n\n# Function evaluates a single player based on the relevant scoring categories and returns a vector with a averaged values each of the scoring categories, and a Raw score value (RAS).\n# -----------------------\n# Implementation notes:\n# - iterates through all of the data sets for the player's data\n# - the standard deviation value is calculated after all the players and their RAS values are calculated\nevaluatePlayer <- function(player, dataSets, aggregated.dataframe, scoringCategories, maxProjectionValues) {\n    # Check if the player name is contained in the data frame\n  if (!grepl(player, aggregated.dataframe['Player'])) {\n    # If the player name is not in the data frame (meaning that it is a new name), generate a vector calculating a projection aggregation and RAS value\n\n    # Generate empty list for to hold the row vectors\n    # Here, we take the player's projections from each data set and generate a data frame holding all of them before calculating the values\n    mergedDataList = list()\n    for (i in 1:length(dataSets)) {\n      playerRowNum <- grep(player, dataSets[[i]]['Player'])\n      if (length(playerRowNum) != 0) {\n        # calculate the RAS value\n        playerVector <- dataSets[[i]][playerRowNum, scoringCategories]\n        RAS <- sum(playerVector / maxProjectedValues[i, scoringCategories])\n        playerVector <- c(playerVector, RAS)\n        \n        # merge the different rows together into a frame\n        mergedDataList = c(mergedDataList, playerVector)\n      }\n      # get RAS value for each\n      # generate a vector for median values and what-not\n    }\n    mergedDataFrame <- Reduce(function(...) merge(..., all = T, mergedDataList))\n    # Aggregate value by calculating the median for projections\n    aggregateVector <- apply(mergedDataFrame, 2, median)\n    \n    # Calculate the RAS value\n    aggregateVector['RAS'] = sum(mergedDataFrame['RAS'])\n    aggregateVector = c(player, aggregateVector)\n    \n    # Aggregate with the overall data frame\n    aggregated.dataframe = rbind(aggregated.dataframe, aggregateVector)\n    \n    #     \n  \n  }\n}\n\n\n# Instead generate all RAS values on the way through\n\n# Return a data frame of the  max projected values for the scoring categories\ngetMaxProjectedValues <- function(dataSets, scoringCategories) {\n  maxProjections = as.data.frame(matrix(0, nrow = length(dataSets), ncol = length(scoringCategories)))\n  names(maxProjections) <- scoringCategories\n  for (i in 1:length(dataSets)) {\n    for(j in 1:length(scoringCategories)) {\n      maxProjections[i, j] = max(dataSets[[i]][scoringCategories[j]])\n    }\n  }\n  return(maxProjections)\n}\n\n\n# Function: rankPositionPlayer\n# ----------------------------\n# 3 inputs: position, vector of ranking categories, dataSets\n# Aggregate ranking based on those positions by adding up the predicted value / predicted max value of category and adding all those up, calculating a standard deviation value\n\n# So I will need two new columns: Raw score, std. deviation\n\n# Also consider: density plots for each individual scoring category so that people can see players who are good for certain categories (e.g. hitting home runs)\nrankPosition <- function(position, scoringCategories, chosenSets) {\n  # Need to subset dataSets to only include the relevant ones to position (e.g. just 1B data)\n  \n  dataSets = list()\n  for (i in 1:length(chosenSets)) {\n    dataSets = c(dataSets, chosenSets[[i]][position])\n  }\n  \n  df = data.frame(0, nrow = getNumPlayers(dataSets), ncol = 2 + length(scoringCategories))\n  names(df) = c('Player', 'Team', scoringCategories)\n\n  # Returns max projected values for each data set. The values are organized by row based on the index of the list \"dataSets\" they were.\n  maxProjectionValues = getMaxProjectedValues(dataSets, scoringCategories)\n  \n  generateRASValues(dataSets, maxProjectionValues, scoringCategories)\n  \n  # use the apply function to rank these\n  for (i in 1:length(dataSets)) {\n    # Max projection values pertaining to the relevant data frame\n    apply(dataSets[[i]]['Player'], 1, function(x) evaluatePlayer(player = x, dataSets = dataSets, aggregated.dataframe = df, scoringCategories = scoringCategories, maxProjectionValues = maxProjectionValues))      \n  }\n  return(df)\n}\n",
    "created" : 1442615695424.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1837212377",
    "id" : "1FDE8B6A",
    "lastKnownWriteTime" : 1442725379,
    "path" : "~/Desktop/FantasyBaseballProjections/BaseballProjectionShinyApp/RankingFunctions.R",
    "project_path" : "BaseballProjectionShinyApp/RankingFunctions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}